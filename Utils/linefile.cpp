// -*- mode: cpp; mode: fold -*-
// Description								/*{{{*/
/* ######################################################################

   Line File - This class performs high speed line reading.

   Benchmarks show that is routine is only slightly quicker than fgets.
   But that is okay, the main features are the memory effeciancy and the
   'Peek' ability.
   
   This source is placed in the Public Domain, do with it what you will
   It was originally written by Jason Gunthorpe <jgg@gpu.srv.ualberta.ca>   
   
   ##################################################################### */
									/*}}}*/
// Includes								/*{{{*/
#include <linefile.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
   									/*}}}*/

// Unix does not have the concept of binaryness, dos and os2 do.
#ifdef __unix__
# define O_BINARY 0
#endif

// LineFile::LineFile - Default Constructor				/*{{{*/
// ---------------------------------------------------------------------
/* Simply allocates the buffer. */
LineFile::LineFile(unsigned long BSize)
{
   Buffer = new char[BSize];
   BEnd = Buffer + BSize;
   Fd = -1;
   Cur = BEnd;
   Peek = 0;
   Size = BSize;
   Error = 0;
}
									/*}}}*/
// LineFile::~LineFile - Destructor					/*{{{*/
// ---------------------------------------------------------------------
/* Free's the buffer */
LineFile::~LineFile()
{
   if (Fd < 0)
      close(Fd);
   
   delete [] Buffer;
}
									/*}}}*/
// LineFile::GetLine - Gets a line from the file			/*{{{*/
// ---------------------------------------------------------------------
/* Exceptions are generated when the line is too long or when their is 
   a file system error. */
bool LineFile::GetLine(char *&Line)
{
   if (Peek != 0)
   {
      Line = Peek;
      Peek = 0;
      return true;
   }
   
   char *Start = Cur;
   Line = 0;
   
   // Loop till we hit a marker
   while (Cur >= BEnd || *Cur != '\n')
   {
      // Search for the next line marker
      for (;Cur < BEnd && *Cur != '\n'; Cur++);
      
      // End of the buffer?
      if (Cur >= BEnd)
      {
	 // Uh oh, really long line
	 if (Start == Buffer)
	 {
	    Error = 1;
	    return false;
	 }
      
	 // Move the end to the start
	 if (Cur == BEnd)
	 {
	    memcpy(Buffer,Start,Cur - Start);
	    Cur = Buffer + (Cur - Start);
	 }
	 else
	    Cur = Buffer;
	 Start = Buffer;
	 
	 // Fill the remaining bit
	 int Rc = read(Fd,Cur,BEnd - Cur);
	 if (Rc < 0)
	 {
	    Error = 1;
	    return false;
	 }
	 	 
	 // Set the proper end 
	 BEnd = Cur + Rc;
	 
	 // No more data, and there is no residual string
	 if (Rc == 0 && Cur == Start)
	    return false;

	 // We have a bit of string that didnt have a \n
	 if (Rc == 0)
	    break;
      }            
   }

   *Cur = 0;
   Cur++;
   Line = Start;
   return true;
}
									/*}}}*/
// LineFile::PeekLine - Peeks at the next line				/*{{{*/
// ---------------------------------------------------------------------
/* This simply calls GetLine and caches the result.*/
bool LineFile::PeekLine(char *&Line)
{
   if (GetLine(Line) == true)
      Peek = Line;
   else
      return false;
   return true;
}
									/*}}}*/
// LineFile::Open - Opens the file for reading				/*{{{*/
// ---------------------------------------------------------------------
/* No exceptions are generated by this. */
bool LineFile::Open(const char *File)
{
   // Close any opened file
   if (Fd < 0)
   {
      close(Fd);
      Fd = -1;
   }

   Fd = open(File,O_RDONLY | O_BINARY,S_IREAD | S_IWRITE);
   if (Fd < 0)
      return false;

   // This forces GetNextLine to read the buffer the first time it's called.
   BEnd = Buffer + Size;
   Cur = BEnd;
   Peek = 0;
   return true;
}
									/*}}}*/
