// -*- mode: cpp; mode: fold -*-
// Description								/*{{{*/
/* ######################################################################

   FormatBase - Base class for all Muse/2 File Formats
   
   This class defines the basic interfaces for both the metaclass and 
   the actual class. 
   
   Various derived classes contain the code to play and inquire file
   formats supported by muse.

   ##################################################################### */
									/*}}}*/
// Includes								/*{{{*/
#include <muse.h>
#include <cmdline.h>
#include <songlist.h>

// File Formats
#include <s3mform.h>
#include <stmform.h>
#include <modform.h>
#include <mtmform.h>
#include <xmform.h>
#include <itform.h>
#include <farform.h>
#include <ultform.h>
#include <669form.h>
#include <ptmform.h>

// Digital output system
#include <dac.h>
#include <ossdsp.h>
#include <m32flat.h>
#include <simpfilt.h>
#include <efxfiltr.h>

// File Output devices
#include <wav.h>
#include <raw.h>
#include <au.h>

// Archivers
#include <gzip.h>

#include <stdio.h>
   									/*}}}*/

// ShowVersionInf - Show version info for File Formats and Output Devs	/*{{{*/
// ---------------------------------------------------------------------
/* This was ripped from an older version of muse */
void ShowVersionInf(SequenceFormatClass &FileFormats,SequenceOutputClass &Outputs)
{
   long MajorV;
   long MinorV;
   
   // Display file formats methoods
   printf("  File Formats:\n");
   SequenceFormatClass::iterator I;
   for (I = FileFormats.begin(); I != FileFormats.end(); I++)
   {
      (*I)->GetVersion(&MajorV,&MinorV);
      printf("   %s (%s) is Version %li.%li\n",(*I)->GetTypeName(),
	     (*I)->GetName(),MajorV,MinorV);
   }

   // Display output methoods
   printf("  Output Methods:\n");
   SequenceOutputClass::iterator I2;
   for (I2 = Outputs.begin(); I2 != Outputs.end(); I2++)
   {
      (*I2)->GetVersion(&MajorV,&MinorV);
      printf("   %s (%s) is Version %li.%li",(*I2)->GetTypeName(),
	     (*I2)->GetName(),MajorV,MinorV);

      int I3 = (*I2)->IsSupported();
      if (I3 == 0xFF)
      {
	 printf("\n");
         continue;
      }

      if (I3 == 0)
	 printf(" (Not Detected)\n");
      else
	 printf(" (Detected, Level=%i)\n",I3);
   }
}
									/*}}}*/
// DumpModuleInfo - Perform some basic queries of the output device	/*{{{*/
// ---------------------------------------------------------------------
/* */
void DumpModuleInfo(museFormatBase &M)
{
   museSongInfo Info;
   M.GetSongInfo(Info);

   printf("  | '%s' A %s\n",Info.Title,Info.TypeName);
   printf("  | Has %u channels, %u orders and %u patterns.\n",Info.Channels,
	  Info.Orders,Info.Patterns);

   if (Info.ModComment != 0)
      printf("Song Comment:\n%s\n",Info.ModComment);
}
									/*}}}*/
// GetClassLists - Get a list of file formats and output devices	/*{{{*/
// ---------------------------------------------------------------------
/* The list is generated by splitting the master list of all metaclass into
   Output and Format lists. */
void GetClassLists(SequenceFormatClass &Formats,SequenceOutputClass &Outputs)
{
   // Get the global class list
   SequenceMetaClass Classes;
   MetaObject::Meta->GetClassList(Classes);

   // Search it for anything derived from museFormatClass or museOutputClass
   SequenceMetaClass::iterator I;
   for (I = Classes.begin(); I != Classes.end(); I++)
   {      
      // Format Class
      if ((*I)->DescendedFrom(museFormatBase::Meta) == true)
      {
	 // Omit the base classes from the list
	 if (((museFormatClass *)(*I))->GetTypeName() == 0)
	    continue;
	 Formats.push_back((museFormatClass *)*I);
	 continue;
      }

      // Output Class
      if ((*I)->DescendedFrom(museOutputBase::Meta) == true)
      {
	 // Omit the base classes from the list
	 if (((museOutputClass *)(*I))->GetTypeName() == 0)
	    continue;
	 Outputs.push_back((museOutputClass *)*I);
	 continue;
      }
   }

   Classes.free();
};
									/*}}}*/
// Link - Dummy function to force linkage of the metaclasses		/*{{{*/
// ---------------------------------------------------------------------
/* The linker will not link in the metaclasses unless they are referenced.
   This functions are all empty. */
void Link()
{
   // Required to force linkage of the various devices.
   museS3MFormat::Meta->Link(); 
   museSTMFormat::Meta->Link(); 
   museMODFormat::Meta->Link(); 
   museWOWFormat::Meta->Link(); 
   museMTMFormat::Meta->Link(); 
   museXMFormat::Meta->Link(); 
   museITFormat::Meta->Link(); 
   museULTFormat::Meta->Link(); 
   muse669Format::Meta->Link(); 
   museFARFormat::Meta->Link(); 
   musePTMFormat::Meta->Link(); 

   // Output to file devices
   museFileWAV::Meta->Link();
   museFileRAW::Meta->Link();
   museFileAU::Meta->Link();
   
   // Archivers
   museGZipArchiver::Meta->Link();
}
									/*}}}*/
// DumpSamples - Print the sample information.				/*{{{*/
// ---------------------------------------------------------------------
/* */
void DumpSamples(museFormatBase *Song)
{
   SequenceSample Samps;
   Song->GetSongSamples(Samps);
   
   int I = 0;
   for (museSample *Cur = Samps.begin(); Cur != Samps.end(); Cur++,I++)
   {
      char Flags[5];
      memset(Flags,'-',sizeof(Flags));
      Flags[sizeof(Flags) - 1] = 0;
      
      // Setup the flags data
      if ((Cur->Flags & INST_Loop) != 0)
	 Flags[0] = 'L';

      if ((Cur->Flags & INST_16Bit) != 0)
	 Flags[1] = '6';
      else
	 Flags[1] = '8';

      if ((Cur->Flags & INST_Signed) != 0)
	 Flags[2] = 'S';
      else
	 Flags[2] = 'U';
      
      if ((Cur->Flags & INST_PingPong) == INST_PingPong)
	 Flags[0] = 'P';

      if ((Cur->Flags & INST_Reverse) != 0)
	 Flags[3] = 'R';

      char Name[100];
      if (Cur->Name != 0)
	 strncpy(Name,Cur->Name,Cur->MaxNameLen);
      else
	 Name[0] = 0;
      Name[Cur->MaxNameLen] = 0;

      printf("%2i,%2lu: %s %22s %6lu->%6lu=%6lu %6luHz %3li\n",
	     I,Cur->InstNo,Flags,Name,Cur->LoopBegin,Cur->LoopEnd,
	     Cur->SampleEnd,Cur->Center,Cur->Volume);
   }
};
									/*}}}*/
// Help - Show help text						/*{{{*/
// ---------------------------------------------------------------------
/* */
void Help()
{
   printf("\n");
   printf(" Usage: muse [options] module1 [module2] ... \n");
   printf("\n");
   printf(" General Options:\n");
   printf("  --versions, -V  Show version information for the components.\n");
   printf("  --debug, -D     Write ./muse.log containing debug information. \n");
   printf("  --help, -h      This help text.\n");
   printf("  --solo=<chan>   Solo a specific channel.\n");
   printf("  --print         Dump pattern data to the screen.\n");
   printf("  --samps         Dump the sample list to the screen.\n");
   printf("  --jump=<ord>    Jump to a specific order and start.\n");
   printf("\n");
   printf(" Digital Mixer Options:\n");
   printf("  --scale=<val>   Set the scaling factor for the output.\n");
   printf("  --8bit          Use 8bit output.\n");
   printf("  --16bit         Use 16bit output.\n");
   printf("  --stereo        Use stereo output.\n");
   printf("  --mono          Use mono output. (Currently DISABLED)\n");
   printf("  --surround      Enable Surround Sound (Enabled by default).\n");
   printf("  --srate=<val>   Set the sampling rate. (Hz)\n");
   printf(" If no options are specified the mixer will attempt to probe your hardware\n");
   printf(" for the highest quality output.\n");
   printf("\n");
   printf(" OSS-DSP Options:\n");
   printf("  --oss-dsp=<val> Select the output device to use. (/dev/dsp)\n");
   printf("\n");
   printf(" Muse was written by Jason Gunthorpe (Culus) and Nicholas Vinen (HB)\n");
   printf(" Bug Reports etc email to Jason Gunthorpe <jgg@gpu.srv.ualberta.ca>\n");
   printf(" The latest version is availible at http://www.ualberta.ca/~jgg/muse\n");
   printf("\n");
   printf("               This Program comes with ABSOLUTELY NO WARRENTY.\n");
   printf("               Use at your own risk.                         \n");
};
									/*}}}*/

int main(char argc,char *argv[])
{
   printf(" Muse Test Frame V1.4 ("__DATE__" "__TIME__") Use -h for info\n");

   // Add a flag to show version information.
   IniOptions *Ini = GetIniOptions();
   Ini->AddOption("versions",0,0,true,'V');
   Ini->AddOption("debug",0,0,true,'D');
   Ini->AddOption("help",0,0,true,'h');
   Ini->AddOption("print",0,0,true);
   Ini->AddOption("samps",0,0,true);
   Ini->AddOption("solo",0,0,false);
   Ini->AddOption("jump",0,0,false);

   // This parses the command line and gives us a list of files.
   SequenceString Files;
   if (Ini->CommandLine(argc,argv,&Files) != 0)
      return 0;

   // Convert the file list into a song list
/*   museSongList Songs;
   for (char **I = Files.begin();I != Files.end(); I++)
      Songs.Add(*I);
   for (museSongList::iterator I = Songs.begin(); I != Songs.end(); I++)
      printf("%s %lu\n",I->FileName,I->Size);

   octet *Block;
   unsigned long Size;
   printf("%u\n",Songs.Load(*Songs.begin(),Block,Size));*/
//   Files.free();
   
   // Show the help screen.
   if (Ini->IsFlag("help") == 1)
   {
      Help();
      return 0;
   }
   
   // Open the debug log.
   if (Ini->IsFlag("debug") == 1)
   {
      DebugFD = fopen("muse.log","wtu");
      printf("Opened muse.log for debug info\n");
   }
   
   // Query the format and output list
   SequenceFormatClass Formats;
   SequenceOutputClass Outputs;
   GetClassLists(Formats,Outputs);
   
   // Print out the version info
   if (Ini->IsFlag("versions") == 1)
   {
      ShowVersionInf(Formats,Outputs);
      return 0;
   }
   
   // Empty files list.
   if (Files.size() == 0)
   {
      printf("No files given.\n");
      return 0;
   }

   
   // Prepare for playback.
   // Open the output device
   museOSSDSP *Output = new museOSSDSP;
   museDACMixer *DAC = (museDACMixer *)Output;
   museOutputClass *OutputClass = (museOutputClass *)Output->GetMetaClass();

   DAC->UseMixer(new museMixerOrg);
 DAC->UseOFilter(new museScaleFilter);
//   DAC->UseOFilter(new museHeavyDeepFilter);

   // Output device init error.
   char *Error;
   if (Output->InitPlay(&Error) != 0)
   {
      printf("Couldn't Initialize device. Error String is '%s'\n",Error);
      return 0;
   }

   museOutputBase *Dev = Output;
   musePlayerControl Play;
   musePrintFilter Printer;
   museEffectFilter EFX;

   // Add the print output filter to the filter stack.
   if (Ini->IsFlag("print") == 1)
   {
      Printer.NextLink = Dev;
      Dev = &Printer;
      printf("Dumping Channel Data\n");
   }
   
   // Add the EFX Output filter to the stack.
   if (Ini->GetArg("solo") != 0)
   {
      EFX.NextLink = Dev;
      Dev = &EFX;
      
      SequenceChanEfx Chans;
      unsigned int I = atoi(Ini->GetArg("solo"));
      if (I < 64)
      {
	 /* Create a 64 Channel array, initialize it and then disable all
	    the channels but the solo chan */
	 Chans[64].Disabled = 1;
	 EFX.InitChanEfx(&Chans);
	 for (museChanEfx *Cur = Chans.begin(); Cur != Chans.end(); Cur++)
	    Cur->Disabled = 1;
	 Chans[I].Disabled = 2;
	 printf("Soloing %u\n",I);
	 EFX.SetChanEfx(&Chans);
	 
	 // Solo the print filter too
	 Printer.SoloChan = I;
      }      
   }
   
   // Print the device description
   char *Desc = Output->GetCurOptionDesc();
   printf("Using %s %s\n",OutputClass->GetTypeName(),Desc);
   delete [] Desc;

   // Do the jump command
   if (Ini->GetArg("jump") != 0)
      Play.Jump(0,atoi(Ini->GetArg("jump")));
   
   // Play all the files given
   for (char **I = Files.begin();I != Files.end(); I++)
   {
      char *FileName = *I;
      
      // Locate the meta class for the file based on file name
      SequenceFormatClass::iterator I = Formats.begin();
      museFormatClass *FileClass = 0;
      for (;I != Formats.end();I++)
      {
	 FileClass = (*I)->GetClassForFile(FileName);
	 if (FileClass != 0)
	    break;
      }
      if (FileClass == 0)
      {
         continue;
      }

      printf("  Loading %s, A %s\n",FileName,FileClass->GetTypeName());

      // Instantiate the actual class,
      museFormatBase *Module = (museFormatBase *)FileClass->New();
      if (Module == 0)
      {
         printf("Fatal Error, unable to instantiate module!\n");
         continue;
      }

      // Load the file (Modules can also be loaded from RAM, LoadMemModule)
      if (Module->LoadModule(FileName) != 0)
      {
         printf(" Loader Error\n");
         continue;
      }

      // Display information about the module (test the loader)
      DumpModuleInfo(*Module);

      // Add the print output filter to the filter stack.
      if (Ini->IsFlag("samps") == 1)
	 DumpSamples(Module);
      
      Module->Play(Dev,&Play);
   }   

   Link();
}
